Calling declaration
In declaration()
In struct_declaration()
Calling declaration
In declaration()
In trait_declaration()
In block()
In prototype()
In block()
In statement()
In var_stmt()
In statement()
In if_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "x" }
In variable()
In primary loop
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: BRACKET_OPEN, value: "(" }
In grouping()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "1" }
In literal()
In primary loop
In primary loop: casting
In primary loop
In primary loop
In block()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "x" }
In variable()
In primary loop
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: BRACKET_OPEN, value: "(" }
In grouping()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "1" }
In literal()
In primary loop
In primary loop: casting
In primary loop
In primary loop
In statement()
In block()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "x" }
In variable()
In primary loop
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: BRACKET_OPEN, value: "(" }
In grouping()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "2" }
In literal()
In primary loop
In primary loop: casting
In primary loop
In primary loop
In statement()
Calling declaration
In declaration()
In impl_declaration()
In block()
In prototype()
In block()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "y" }
In variable()
In primary loop
In statement()
In block()
In prototype()
In block()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "10" }
In literal()
In primary loop
In statement()
Calling declaration
In declaration()
In impl_declaration()
In block()
In prototype()
In block()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "20" }
In literal()
In primary loop
In statement()
Calling declaration
In declaration()
In block()
In prototype()
In block()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "10" }
In literal()
In primary loop
In statement()
Calling declaration
In declaration()
In block()
In prototype()
In block()
In statement()
In var_stmt()
In statement()
In var_stmt()
In statement()
In var_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "hello" }
In struct_expr()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "y" }
In variable()
In primary loop
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "z" }
In variable()
In primary loop
In primary loop
In statement()
In expr_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "x" }
In variable()
In primary loop
In primary loop: attributeref
In primary loop
In primary loop: call
In expression_list()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: BRACKET_CLOSE, value: ")" }
Returning none from atom
In primary loop
In statement()
In statement()
In expr_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "main2" }
In variable()
In primary loop
In primary loop: call
In expression_list()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: BRACKET_CLOSE, value: ")" }
Returning none from atom
In primary loop
In statement()
Variable datatype: int32
Literal expr type: int64
Exprlist type: int32
Binary expr :::: Lhs type: int32, Rhs type: int32
Exprlist type: bool
Variable datatype: int32
Literal expr type: int64
Exprlist type: int32
Binary expr :::: Lhs type: int32, Rhs type: int32
Exprlist type: int32
Variable datatype: int32
Literal expr type: int64
Exprlist type: int32
Binary expr :::: Lhs type: int32, Rhs type: int32
Exprlist type: int32
Variable datatype: int32
Exprlist type: int32
Literal expr type: int64
Exprlist type: int64
Literal expr type: int64
Exprlist type: int64
Literal expr type: int64
Exprlist type: int64
Variable datatype: int32
Variable datatype: int64
Exprlist type: object { name: "hello" }
Variable datatype: object { name: "hello" }
Exprlist type: yet_to_infer
Exprlist type: int64
Codegen-Prototype: name:hell.newhell
Codegen-Prototype: num_params:0
Codegen-Prototype: name:hello.new
Codegen-Prototype: num_params:2
Codegen-Prototype: name:hello.new2
Codegen-Prototype: num_params:1
Codegen-Prototype: name:hello.newhell
Codegen-Prototype: num_params:1
Codegen-Prototype: name:main2
Codegen-Prototype: num_params:0
Codegen-Prototype: name:main
Codegen-Prototype: num_params:0
Symbol Table: IRSymbolTable {
    variable_table: {
        "x": PointerValue {
            ptr_value: Value {
                name: "x",
                address: 0x000055634ed9cc60,
                is_const: false,
                is_null: false,
                is_undef: false,
                llvm_value: "  %x = alloca %hello, align 8",
                llvm_type: "%hello*",
            },
        },
        "y": PointerValue {
            ptr_value: Value {
                name: "y",
                address: 0x000055634ed9ef10,
                is_const: false,
                is_null: false,
                is_undef: false,
                llvm_value: "  %y = alloca i32, align 4",
                llvm_type: "i32*",
            },
        },
        "z": PointerValue {
            ptr_value: Value {
                name: "z",
                address: 0x000055634eda37e0,
                is_const: false,
                is_null: false,
                is_undef: false,
                llvm_value: "  %z = alloca i64, align 8",
                llvm_type: "i64*",
            },
        },
    },
    struct_decls: {
        "hello": StructDecl {
            name: Token{ tok_type: IDENTIFIER, value: "hello" },
            fields: [
                (
                    Token{ tok_type: IDENTIFIER, value: "x" },
                    Token{ tok_type: K_INT32, value: "int32" },
                ),
                (
                    Token{ tok_type: IDENTIFIER, value: "y" },
                    Token{ tok_type: K_INT64, value: "int64" },
                ),
            ],
        },
    },
    impl_decls: {},
    trait_decls: {},
    func_table: {},
}
=======================LLVM IR=======================
; ModuleID = 'main_mod'
source_filename = "main_mod"

%hello = type { i32, i64 }

define i32 @hell.newhell() {
entry:
  %x = alloca i32, align 4
  %x.load = load i32, i32* %x, align 4
  %integer.unsigned.eqeq_ = icmp eq i32 %x.load, 1
  br i1 %integer.unsigned.eqeq_, label %then, label %else

then:                                             ; preds = %entry
  %x.load1 = load i32, i32* %x, align 4
  %integer.add_ = add i32 %x.load1, 1
  ret i32 %integer.add_
  br label %ifcont

else:                                             ; preds = %entry
  %x.load2 = load i32, i32* %x, align 4
  %integer.add_3 = add i32 %x.load2, 2
  ret i32 %integer.add_3
  br label %ifcont

ifcont:                                           ; preds = %else, %then
}

define i32 @hello.new(%hello* %self, i32 %y) {
entry:
  %y2 = alloca i32, align 4
  %self1 = alloca %hello*, align 8
  store %hello* %self, %hello** %self1, align 8
  store i32 %y, i32* %y2, align 4
  %y.load = load i32, i32* %y2, align 4
  ret i32 %y.load
  ret void
}

define i32 @hello.new2(%hello* %self) {
entry:
  %self1 = alloca %hello*, align 8
  store %hello* %self, %hello** %self1, align 8
  ret i64 10
  ret void
}

define i32 @hello.newhell(%hello* %self) {
entry:
  %self1 = alloca %hello*, align 8
  store %hello* %self, %hello** %self1, align 8
  ret i64 20
  ret void
}

define i64 @main2() {
entry:
  ret i64 10
  ret void
}

define i32 @main() {
entry:
  %y = alloca i32, align 4
  %z = alloca i64, align 8
  %y.load = load i32, i32* %y, align 4
  %z.load = load i64, i64* %z, align 4
  %x = alloca %hello, align 8
  store %hello { i32 %y.load, i64 %z.load }, %hello* %x, align 4
  %hello.new..call = call i32 @hello.new(%hello* %x)
  %main2..call = call i64 @main2()
  ret i64 %main2..call
}

=====================================================
Err(
    "Basic Block in function \'hell.newhell\' does not have terminator!\nlabel %ifcont\nTerminator found in the middle of a basic block!\nlabel %entry\nFunction return type does not match operand type of return inst!\n  ret void\n i32Function return type does not match operand type of return inst!\n  ret i64 10\n i32Function return type does not match operand type of return inst!\n  ret void\n i32Function return type does not match operand type of return inst!\n  ret i64 20\n i32Function return type does not match operand type of return inst!\n  ret void\n i32Terminator found in the middle of a basic block!\nlabel %entry\nFunction return type does not match operand type of return inst!\n  ret void\n i64Use of instruction is not an instruction!\n  %y.load = load i32, i32* %y, align 4\nUse of instruction is not an instruction!\n  %z.load = load i64, i64* %z, align 4\nIncorrect number of arguments passed to called function!\n  %hello.new..call = call i32 @hello.new(%hello* %x)\nFunction return type does not match operand type of return inst!\n  ret i64 %main2..call\n i32",
)
