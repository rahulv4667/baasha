
File content:
struct hello {
    x: int32
}

func main() -> int32  {
    a = 20 as int32, 10 as int64;
}
========================================================================
Token{ tok_type: K_STRUCT, value: "struct" }
Token{ tok_type: IDENTIFIER, value: "hello" }
Token{ tok_type: CURLY_OPEN, value: "{" }
Token{ tok_type: IDENTIFIER, value: "x" }
Token{ tok_type: COLON, value: ":" }
Token{ tok_type: K_INT32, value: "int32" }
Token{ tok_type: CURLY_CLOSE, value: "}" }
Token{ tok_type: K_FUNC, value: "func" }
Token{ tok_type: IDENTIFIER, value: "main" }
Token{ tok_type: BRACKET_OPEN, value: "(" }
Token{ tok_type: BRACKET_CLOSE, value: ")" }
Token{ tok_type: RIGHT_ARROW, value: "->" }
Token{ tok_type: K_INT32, value: "int32" }
Token{ tok_type: CURLY_OPEN, value: "{" }
Token{ tok_type: IDENTIFIER, value: "a" }
Token{ tok_type: EQUAL, value: "=" }
Token{ tok_type: INT_LITERAL, value: "20" }
Token{ tok_type: K_AS, value: "as" }
Token{ tok_type: K_INT32, value: "int32" }
Token{ tok_type: COMMA, value: "," }
Token{ tok_type: INT_LITERAL, value: "10" }
Token{ tok_type: K_AS, value: "as" }
Token{ tok_type: K_INT64, value: "int64" }
Token{ tok_type: SEMICOLON, value: ";" }
Token{ tok_type: CURLY_CLOSE, value: "}" }
Token{ tok_type: FILE_EOF, value: "" }
=========================================================================
Calling declaration
In declaration()
In struct_declaration()
Calling declaration
In declaration()
In block()
In prototype()
In block()
In statement()
In expr_stmt()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "a" }
In variable()
In expression_list()
In expression()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "20" }
In literal()
In expression()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "10" }
In literal()
In statement()
Declarations: 2
|
|
StructDecl{ Name: Token{ tok_type: IDENTIFIER, value: "hello" } }
          Fields{{ }}
          Field name: Token{ tok_type: IDENTIFIER, value: "x" }, datatype: Token{ tok_type: K_INT32, value: "int32" }
|
|
FuncDef{{ }}
          |
          |
          Prototype{ Name:Token{ tok_type: IDENTIFIER, value: "main" } }
                    Parameters {{ }}
                    ReturnTypes{{ }}
                    Type:Token{ tok_type: K_INT32, value: "int32" }
          |
          |
          Block{{ }}
                 |
                 |
                 Expression{{ }}
                              |
                              |
                              Assignment{{ }}
                                           Target
                                           |
                                           |
                                           Identifier{ Name:Token{ tok_type: IDENTIFIER, value: "a" }, Datatype:yet_to_infer }
                                           Source
                                           |
                                           |
                                           Cast{ cast_to: Token{ tok_type: K_INT32, value: "int32" } }
                                                |
                                                |
                                                Primary{ value:Token{ tok_type: INT_LITERAL, value: "20" }, datatype: yet_to_infer }
                                           Source
                                           |
                                           |
                                           Cast{ cast_to: Token{ tok_type: K_INT64, value: "int64" } }
                                                |
                                                |
                                                Primary{ value:Token{ tok_type: INT_LITERAL, value: "10" }, datatype: yet_to_infer }
