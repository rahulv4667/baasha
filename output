Calling declaration
In declaration()
In struct_declaration()
Calling declaration
In declaration()
In trait_declaration()
In block()
In prototype()
In block()
In statement()
In var_stmt()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: K_IF, value: "if" }
Returning none from atom
In statement()
In if_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "x" }
In variable()
In primary loop
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: BRACKET_OPEN, value: "(" }
In grouping()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "1" }
In literal()
In primary loop
In primary loop: casting
In primary loop
In primary loop
In block()
In statement()
In expr_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "x" }
In variable()
In primary loop
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: BRACKET_OPEN, value: "(" }
In grouping()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "1" }
In literal()
In primary loop
In primary loop: casting
In primary loop
In primary loop
In statement()
In block()
In statement()
In expr_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "x" }
In variable()
In primary loop
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: BRACKET_OPEN, value: "(" }
In grouping()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "2" }
In literal()
In primary loop
In primary loop: casting
In primary loop
In primary loop
In statement()
Calling declaration
In declaration()
In impl_declaration()
In block()
In prototype()
In block()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "y" }
In variable()
In primary loop
In statement()
In block()
In prototype()
In block()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: BRACKET_OPEN, value: "(" }
In grouping()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "10" }
In literal()
In primary loop
In primary loop: casting
In primary loop
In primary loop
In statement()
Calling declaration
In declaration()
In impl_declaration()
In block()
In prototype()
In block()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: BRACKET_OPEN, value: "(" }
In grouping()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "20" }
In literal()
In primary loop
In primary loop: casting
In primary loop
In primary loop
In statement()
Calling declaration
In declaration()
In block()
In prototype()
In block()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "10" }
In literal()
In primary loop
In statement()
Calling declaration
In declaration()
In block()
In prototype()
In block()
In statement()
In var_stmt()
In statement()
In var_stmt()
In statement()
In expr_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "y" }
In variable()
In primary loop
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "10" }
In literal()
In primary loop
In primary loop: casting
In primary loop
In statement()
In statement()
In var_stmt()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "hello" }
In struct_expr()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "y" }
In variable()
In primary loop
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "z" }
In variable()
In primary loop
In primary loop
In statement()
In expr_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "x" }
In variable()
In primary loop
In primary loop: attributeref
In primary loop
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "10" }
In literal()
In primary loop
In primary loop: casting
In primary loop
In statement()
In statement()
In expr_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "x" }
In variable()
In primary loop
In primary loop: attributeref
In primary loop
In primary loop: call
In expression_list()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "y" }
In variable()
In primary loop
In primary loop
In statement()
In statement()
In expr_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: IDENTIFIER, value: "main2" }
In variable()
In primary loop
In primary loop: call
In expression_list()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: BRACKET_CLOSE, value: ")" }
Returning none from atom
In primary loop
In statement()
In statement()
In return_stmt()
In expression()
In assignment()
In logical_OR_expr()
In logical_AND_expr()
In inclusive_OR_expr()
In exclusive_OR_expr()
In AND_expr()
In equality_expr()
In relational_expr()
In shift_expr()
In additive_expr()
In multiplicative_expr()
In unary_expr()
In primary()
In atom()
Peek: Token{ tok_type: INT_LITERAL, value: "10" }
In literal()
In primary loop
In statement()
Variable datatype: int32
Literal expr type: int64
Exprlist type: int32
Binary expr :::: Lhs type: int32, Rhs type: int32
Exprlist type: bool
Variable datatype: int32
Literal expr type: int64
Exprlist type: int32
Binary expr :::: Lhs type: int32, Rhs type: int32
Exprlist type: int32
Variable datatype: int32
Literal expr type: int64
Exprlist type: int32
Binary expr :::: Lhs type: int32, Rhs type: int32
Exprlist type: int32
Variable datatype: int32
Exprlist type: int32
Literal expr type: int64
Exprlist type: int32
Exprlist type: int32
Literal expr type: int64
Exprlist type: int32
Exprlist type: int32
Literal expr type: int64
Exprlist type: int64
Variable datatype: int32
Literal expr type: int64
Exprlist type: int32
Variable datatype: int32
Variable datatype: int32
Variable datatype: object { name: "hello" }
Literal expr type: int64
Exprlist type: int32
Variable datatype: object { name: "hello" }
Exprlist type: yet_to_infer
Exprlist type: int64
Literal expr type: int64
Exprlist type: int64
Codegen-Prototype: name:hell.newhell
Codegen-Prototype: num_params:0
Codegen-VariableExpr: PointerValue {
    ptr_value: Value {
        name: "x",
        address: 0x0000563ca7b1b870,
        is_const: false,
        is_null: false,
        is_undef: false,
        llvm_value: "  %x = alloca i32, align 4",
        llvm_type: "i32*",
    },
}
Codegen-VariableExpr: PointerValue {
    ptr_value: Value {
        name: "x",
        address: 0x0000563ca7b1b870,
        is_const: false,
        is_null: false,
        is_undef: false,
        llvm_value: "  %x = alloca i32, align 4",
        llvm_type: "i32*",
    },
}
Codegen-VariableExpr: PointerValue {
    ptr_value: Value {
        name: "x",
        address: 0x0000563ca7b1b870,
        is_const: false,
        is_null: false,
        is_undef: false,
        llvm_value: "  %x = alloca i32, align 4",
        llvm_type: "i32*",
    },
}
Codegen-IfStmt: Then_val: IntValue(
    IntValue {
        int_value: Value {
            name: "integer.add_",
            address: 0x0000563ca7b2c290,
            is_const: false,
            is_null: false,
            is_undef: false,
            llvm_value: "  %integer.add_ = add i32 %x.load1, 1",
            llvm_type: "i32",
        },
    },
)
Codegen-IfStmt: Else_val: IntValue(
    IntValue {
        int_value: Value {
            name: "integer.add_3",
            address: 0x0000563ca7b2e2a0,
            is_const: false,
            is_null: false,
            is_undef: false,
            llvm_value: "  %integer.add_3 = add i32 %x.load2, 2",
            llvm_type: "i32",
        },
    },
)
Codegen-IfStmt: Ok(
    "  %ifphi = phi i32 [ %integer.add_, %then ], [ %integer.add_3, %else ]",
)
Codegen-Prototype: name:hello.new
Codegen-Prototype: num_params:2
Codegen-VariableExpr: PointerValue {
    ptr_value: Value {
        name: "y2",
        address: 0x0000563ca7b2a130,
        is_const: false,
        is_null: false,
        is_undef: false,
        llvm_value: "  %y2 = alloca i32, align 4",
        llvm_type: "i32*",
    },
}
Codegen-Prototype: name:hello.new2
Codegen-Prototype: num_params:1
Codegen-Prototype: name:hello.newhell
Codegen-Prototype: num_params:1
Codegen-Prototype: name:main2
Codegen-Prototype: num_params:0
Codegen-Prototype: name:main
Codegen-Prototype: num_params:0
Codegen-AssignmentExpr: lhs_ptr.is_ptr()=true
Codegen-AssignmentExpr: TokenType::EQUAL
Codegen-VarStmt: name: Token{ tok_type: IDENTIFIER, value: "x" }, datatype: Some(
    Token{ tok_type: IDENTIFIER, value: "hello" },
), init_value: Some(
    StructExpr {
        struct_name: Token{ tok_type: IDENTIFIER, value: "hello" },
        fields: [
            (
                Token{ tok_type: IDENTIFIER, value: "x" },
                Variable {
                    name: Token{ tok_type: IDENTIFIER, value: "y" },
                    datatype: int32,
                    struct_name: None,
                },
            ),
            (
                Token{ tok_type: IDENTIFIER, value: "y" },
                Variable {
                    name: Token{ tok_type: IDENTIFIER, value: "z" },
                    datatype: int32,
                    struct_name: None,
                },
            ),
        ],
        datatype: object {
            name: "hello",
        },
    },
)
Codegen-ObjAssignExpr: LHS: PointerValue(
    PointerValue {
        ptr_value: Value {
            name: "x",
            address: 0x0000563ca7b0d5c0,
            is_const: false,
            is_null: false,
            is_undef: false,
            llvm_value: "  %x = alloca %hello, align 8",
            llvm_type: "%hello*",
        },
    },
)
Codegen-ObjAssignExpr: StructDecl: [
    (
        Token{ tok_type: IDENTIFIER, value: "x" },
        Token{ tok_type: K_INT32, value: "int32" },
    ),
    (
        Token{ tok_type: IDENTIFIER, value: "y" },
        Token{ tok_type: K_INT32, value: "int32" },
    ),
]
Codegen-ObjAssignExpr: Expr: StructExpr {
    struct_name: Token{ tok_type: IDENTIFIER, value: "hello" },
    fields: [
        (
            Token{ tok_type: IDENTIFIER, value: "x" },
            Variable {
                name: Token{ tok_type: IDENTIFIER, value: "y" },
                datatype: int32,
                struct_name: None,
            },
        ),
        (
            Token{ tok_type: IDENTIFIER, value: "y" },
            Variable {
                name: Token{ tok_type: IDENTIFIER, value: "z" },
                datatype: int32,
                struct_name: None,
            },
        ),
    ],
    datatype: object {
        name: "hello",
    },
}
Codegen-ObjAssignExpr: Fields: [
    (
        Token{ tok_type: IDENTIFIER, value: "x" },
        Variable {
            name: Token{ tok_type: IDENTIFIER, value: "y" },
            datatype: int32,
            struct_name: None,
        },
    ),
    (
        Token{ tok_type: IDENTIFIER, value: "y" },
        Variable {
            name: Token{ tok_type: IDENTIFIER, value: "z" },
            datatype: int32,
            struct_name: None,
        },
    ),
]
Codegen-VariableExpr: PointerValue {
    ptr_value: Value {
        name: "y",
        address: 0x0000563ca7b24f60,
        is_const: false,
        is_null: false,
        is_undef: false,
        llvm_value: "  %y = alloca i32, align 4",
        llvm_type: "i32*",
    },
}
Codegen-VariableExpr: PointerValue {
    ptr_value: Value {
        name: "z",
        address: 0x0000563ca7b31b70,
        is_const: false,
        is_null: false,
        is_undef: false,
        llvm_value: "  %z = alloca i32, align 4",
        llvm_type: "i32*",
    },
}
Codegen-VarStmt: VarExpr: Variable {
    name: Token{ tok_type: IDENTIFIER, value: "x" },
    datatype: object {
        name: "hello",
    },
    struct_name: Some(
        "hello",
    ),
}
Codegen-VarStmt: AssignmentExpr: Assignment {
    target: Variable {
        name: Token{ tok_type: IDENTIFIER, value: "x" },
        datatype: object {
            name: "hello",
        },
        struct_name: Some(
            "hello",
        ),
    },
    operator: Token{ tok_type: EQUAL, value: "=" },
    expr: StructExpr {
        struct_name: Token{ tok_type: IDENTIFIER, value: "hello" },
        fields: [
            (
                Token{ tok_type: IDENTIFIER, value: "x" },
                Variable {
                    name: Token{ tok_type: IDENTIFIER, value: "y" },
                    datatype: int32,
                    struct_name: None,
                },
            ),
            (
                Token{ tok_type: IDENTIFIER, value: "y" },
                Variable {
                    name: Token{ tok_type: IDENTIFIER, value: "z" },
                    datatype: int32,
                    struct_name: None,
                },
            ),
        ],
        datatype: object {
            name: "hello",
        },
    },
    datatype: object {
        name: "hello",
    },
}
Codegen-VarStmt: Result: StructValue(
    StructValue {
        struct_value: Value {
            name: "ptr.load",
            address: 0x0000563ca7b31e50,
            is_const: false,
            is_null: false,
            is_undef: false,
            llvm_value: "  %ptr.load = load %hello, %hello* %x, align 4",
            llvm_type: "%hello = type { i32, i32 }",
        },
    },
)
Codegen-AssignmentExpr: lhs_ptr.is_ptr()=true
Codegen-AssignmentExpr: TokenType::EQUAL
Symbol Table: IRSymbolTable {
    variable_table: {
        "y": PointerValue {
            ptr_value: Value {
                name: "y",
                address: 0x0000563ca7b24f60,
                is_const: false,
                is_null: false,
                is_undef: false,
                llvm_value: "  %y = alloca i32, align 4",
                llvm_type: "i32*",
            },
        },
        "z": PointerValue {
            ptr_value: Value {
                name: "z",
                address: 0x0000563ca7b31b70,
                is_const: false,
                is_null: false,
                is_undef: false,
                llvm_value: "  %z = alloca i32, align 4",
                llvm_type: "i32*",
            },
        },
        "x": PointerValue {
            ptr_value: Value {
                name: "x",
                address: 0x0000563ca7b0d5c0,
                is_const: false,
                is_null: false,
                is_undef: false,
                llvm_value: "  %x = alloca %hello, align 8",
                llvm_type: "%hello*",
            },
        },
    },
    struct_decls: {
        "hello": StructDecl {
            name: Token{ tok_type: IDENTIFIER, value: "hello" },
            fields: [
                (
                    Token{ tok_type: IDENTIFIER, value: "x" },
                    Token{ tok_type: K_INT32, value: "int32" },
                ),
                (
                    Token{ tok_type: IDENTIFIER, value: "y" },
                    Token{ tok_type: K_INT32, value: "int32" },
                ),
            ],
        },
    },
    impl_decls: {},
    trait_decls: {},
    func_table: {},
}
Codegen-VariableExpr: PointerValue {
    ptr_value: Value {
        name: "y",
        address: 0x0000563ca7b24f60,
        is_const: false,
        is_null: false,
        is_undef: false,
        llvm_value: "  %y = alloca i32, align 4",
        llvm_type: "i32*",
    },
}
=======================LLVM IR=======================
; ModuleID = 'main_mod'
source_filename = "main_mod"

%hello = type { i32, i32 }

define i32 @hell.newhell() {
entry:
  %x = alloca i32, align 4
  %x.load = load i32, i32* %x, align 4
  %integer.unsigned.eqeq_ = icmp eq i32 %x.load, 1
  br i1 %integer.unsigned.eqeq_, label %then, label %else

then:                                             ; preds = %entry
  %x.load1 = load i32, i32* %x, align 4
  %integer.add_ = add i32 %x.load1, 1
  br label %ifcont

else:                                             ; preds = %entry
  %x.load2 = load i32, i32* %x, align 4
  %integer.add_3 = add i32 %x.load2, 2
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  %ifphi = phi i32 [ %integer.add_, %then ], [ %integer.add_3, %else ]
  ret i32 %ifphi
}

define i32 @hello.new(%hello* %self, i32 %y) {
entry:
  %y2 = alloca i32, align 4
  %self1 = alloca %hello*, align 8
  store %hello* %self, %hello** %self1, align 8
  store i32 %y, i32* %y2, align 4
  %y.load = load i32, i32* %y2, align 4
  ret i32 %y.load
}

define i32 @hello.new2(%hello* %self) {
entry:
  %self1 = alloca %hello*, align 8
  store %hello* %self, %hello** %self1, align 8
  ret i32 10
}

define i32 @hello.newhell(%hello* %self) {
entry:
  %self1 = alloca %hello*, align 8
  store %hello* %self, %hello** %self1, align 8
  ret i32 20
}

define i64 @main2() {
entry:
  ret i64 10
}

define i64 @main() {
entry:
  %y = alloca i32, align 4
  %z = alloca i32, align 4
  store i32 10, i32* %y, align 4
  %x = alloca %hello, align 8
  %x1 = getelementptr inbounds %hello, %hello* %x, i32 0, i32 0
  %y.load = load i32, i32* %y, align 4
  store i32 %y.load, i32* %x1, align 4
  %y2 = getelementptr inbounds %hello, %hello* %x, i32 0, i32 1
  %z.load = load i32, i32* %z, align 4
  store i32 %z.load, i32* %y2, align 4
  %ptr.load = load %hello, %hello* %x, align 4
  %hello.x..ptr = getelementptr inbounds %hello, %hello* %x, i32 0, i32 0
  store i32 10, i32* %hello.x..ptr, align 4
  %y.load3 = load i32, i32* %y, align 4
  %hello.new..call = call i32 @hello.new(%hello* %x, i32 %y.load3)
  %main2..call = call i64 @main2()
  ret i64 10
}

=====================================================
Ok(
    (),
)
